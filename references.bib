@article{8118483,
  author  = {L. {Wagner}},
  journal = {IEEE Spectrum},
  title   = {Turbocharging the web},
  year    = {2017},
  volume  = {54},
  number  = {12},
  pages   = {48-53},
  doi     = {10.1109/MSPEC.2017.8118483}
}

@inproceedings{10.1145/3062341.3062363,
  author    = {Haas, Andreas and Rossberg, Andreas and Schuff, Derek L. and Titzer, Ben L. and Holman, Michael and Gohman, Dan and Wagner, Luke and Zakai, Alon and Bastien, JF},
  title     = {Bringing the Web up to Speed with {W}eb{A}ssembly},
  year      = {2017},
  isbn      = {9781450349888},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3062341.3062363},
  doi       = {10.1145/3062341.3062363},
  abstract  = { The maturation of the Web platform has given rise to sophisticated and demanding Web applications such as interactive 3D visualization, audio and video software, and games. With that, efficiency and security of code on the Web has become more important than ever. Yet JavaScript as the only built-in language of the Web is not well-equipped to meet these requirements, especially as a compilation target.  Engineers from the four major browser vendors have risen to the challenge and collaboratively designed a portable low-level bytecode called WebAssembly. It offers compact representation, efficient validation and compilation, and safe low to no-overhead execution. Rather than committing to a specific programming model, WebAssembly is an abstraction over modern hardware, making it language-, hardware-, and platform-independent, with use cases beyond just the Web. WebAssembly has been designed with a formal semantics from the start. We describe the motivation, design and formal semantics of WebAssembly and provide some preliminary experience with implementations. },
  booktitle = {Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  pages     = {185–200},
  numpages  = {16},
  keywords  = {type systems, virtual machines, just-in-time compilers, assembly languages, programming languages},
  location  = {Barcelona, Spain},
  series    = {PLDI 2017}
}

@inproceedings{10.1145/3167082,
  author    = {Watt, Conrad},
  title     = {Mechanising and Verifying the {W}eb{A}ssembly Specification},
  year      = {2018},
  isbn      = {9781450355865},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3167082},
  doi       = {10.1145/3167082},
  abstract  = {WebAssembly is a new low-level language currently being implemented in all major web browsers. It is designed to become the universal compilation target for the web, obsoleting existing solutions in this area, such as asm.js and Native Client. The WebAssembly working group has incorporated formal techniques into the development of the language, but their efforts so far have focussed on pen and paper formal specification.We present a mechanised Isabelle specification for the WebAssembly language, together with a verified executable interpreter and type checker. Moreover, we present a fully mechanised proof of the soundness of the WebAssembly type system, and detail how our work on this proof has exposed several issues with the official WebAssembly specification, influencing its development. Finally, we give a brief account of our efforts in performing differential fuzzing of our interpreter against industry implementations.},
  booktitle = {Proceedings of the 7th ACM SIGPLAN International Conference on Certified Programs and Proofs},
  pages     = {53–65},
  numpages  = {13},
  keywords  = {bytecode, stack machine, soundness, reduction},
  location  = {Los Angeles, CA, USA},
  series    = {CPP 2018}
}

@inproceedings{10.1145/2048147.2048224,
  author    = {Zakai, Alon},
  title     = {Emscripten: An {LLVM}-to-{J}ava{S}cript Compiler},
  year      = {2011},
  isbn      = {9781450309424},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2048147.2048224},
  doi       = {10.1145/2048147.2048224},
  abstract  = {We present Emscripten, a compiler from LLVM (Low Level Virtual Machine) assembly to JavaScript. This opens up two avenues for running code written in languages other than JavaScript on the web: (1) Compile code directly into LLVM assembly, and then compile that into JavaScript using Emscripten, or (2) Compile a language's entire runtime into LLVM and then JavaScript, as in the previous approach, and then use the compiled runtime to run code written in that language. For example, the former approach can work for C and C++, while the latter can work for Python; all three examples open up new opportunities for running code on the web.Emscripten itself is written in JavaScript and is available under the MIT license (a permissive open source license), at http://www.emscripten.org. As a compiler from LLVM to JavaScript, the challenges in designing Emscripten are somewhat the reverse of the norm - one must go from a low-level assembly into a high-level language, and recreate parts of the original high-level structure of the code that were lost in the compilation to low-level LLVM. We detail the methods used in Emscripten to deal with those challenges, and in particular present and prove the validity of Emscripten's Relooper algorithm, which recreates high-level loop structures from low-level branching data.},
  booktitle = {Proceedings of the ACM International Conference Companion on Object Oriented Programming Systems Languages and Applications Companion},
  pages     = {301–312},
  numpages  = {12},
  keywords  = {llvm, javascript, decompiler},
  location  = {Portland, Oregon, USA},
  series    = {OOPSLA '11}
}

@inproceedings{234914,
  author    = {Abhinav Jangda and Bobby Powers and Emery D. Berger and Arjun Guha},
  title     = {Not So Fast: Analyzing the Performance of {W}eb{A}ssembly vs. Native Code},
  booktitle = {2019 {USENIX} Annual Technical Conference ({USENIX} {ATC} 19)},
  year      = {2019},
  isbn      = {978-1-939133-03-8},
  address   = {Renton, WA},
  pages     = {107--120},
  url       = {https://www.usenix.org/conference/atc19/presentation/jangda},
  publisher = {{USENIX} Association},
  month     = jul
}

@masterthesis{llvm-thesis,
  author  = {Chris Lattner},
  title   = {{LLVM: An Infrastructure for Multi-Stage Optimization}},
  school  = {{Computer Science Dept., University of Illinois at Urbana-Champaign}},
  year    = {2002},
  address = {Urbana, IL},
  month   = {Dec}
}

@inproceedings{adler32-paper,
  author    = {C. {Fetzer}},
  booktitle = {International Conference on Dependable Systems and Networks (DSN'06)},
  title     = {Student Forum},
  year      = {2006},
  volume    = {},
  number    = {},
  pages     = {594-594},
  doi       = {10.1109/DSN.2006.68}
}

@article{ibm-ssa,
  author     = {Cytron, Ron and Ferrante, Jeanne and Rosen, Barry K. and Wegman, Mark N. and Zadeck, F. Kenneth},
  title      = {Efficiently Computing Static Single Assignment Form and the Control Dependence Graph},
  year       = {1991},
  issue_date = {Oct. 1991},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {13},
  number     = {4},
  issn       = {0164-0925},
  url        = {https://doi.org/10.1145/115372.115320},
  doi        = {10.1145/115372.115320},
  journal    = {ACM Trans. Program. Lang. Syst.},
  month      = oct,
  pages      = {451–490},
  numpages   = {40},
  keywords   = {def-use chain, optimizing compilers, control flow graph, control dependence, dominator}
}

@inproceedings{trufflewasm,
  author    = {Salim, Salim S. and Nisbet, Andy and Luj\'{a}n, Mikel},
  title     = {TruffleWasm: A WebAssembly Interpreter on GraalVM},
  year      = {2020},
  isbn      = {9781450375542},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3381052.3381325},
  doi       = {10.1145/3381052.3381325},
  abstract  = {WebAssembly is a binary format originally designed for web-based deployment and execution combined with JavaScript. WebAssembly can also be used for standalone programs provided a WebAssembly runtime environment is available.This paper describes the design and implementation of TruffleWasm, a guest language implementation of a WebAssembly hosted on Truffle and GraalVM. Truffle is a Java framework capable of constructing and interpreting an Abstract Syntax Tree (AST) representing a program on standard JVMs. GraalVM is a JVM with a JIT compiler which optimises the execution of ASTs from Truffle.Our work is motivated by trying to understand the advantages and disadvantages of using GraalVM, and its support for multiple programming languages, to build a standalone WebAssembly runtime. This contrast with developing a new runtime, as Wasmtime and other projects are undertaking. TruffleWasm can execute standalone WebAssembly modules, while offering also interoperability with other GraalVM hosted languages, such as Java, JavaScript, R, Python and Ruby.The experimental results compare the peak performance of TruffleWasm to the standalone Wasmtime runtime for the Shootout, C benchmarks in JetStream, and the Poly-BenchC benchmarks. The results show the geo-mean peak performance of TruffleWasm is 4% slower than Wasmtime for Shootout/JetStream, and 4% faster for PolyBenchC.},
  booktitle = {Proceedings of the 16th ACM SIGPLAN/SIGOPS International Conference on Virtual Execution Environments},
  pages     = {88–100},
  numpages  = {13},
  keywords  = {WebAssembly, JVM, just in time compilation, Wasm, GraalVM},
  location  = {Lausanne, Switzerland},
  series    = {VEE '20}
}

@inproceedings{auto-vec-gcc,
  author    = {D. {Nuzman} and R. {Henderson}},
  booktitle = {International Symposium on Code Generation and Optimization (CGO'06)},
  title     = {Multi-platform auto-vectorization},
  year      = {2006},
  volume    = {},
  number    = {},
  pages     = {11 pp.-294},
  doi       = {10.1109/CGO.2006.25}
}

@article{sse-intel,
  author  = {S. K. {Raman} and V. {Pentkovski} and J. {Keshava}},
  journal = {IEEE Micro},
  title   = {Implementing streaming SIMD extensions on the Pentium III processor},
  year    = {2000},
  volume  = {20},
  number  = {4},
  pages   = {47-57},
  doi     = {10.1109/40.865866}
}

@inproceedings{arm-neon,
  author    = {Jang, Minwoo and Kim, Kukhyun and Kim, Kanghee},
  title     = {The Performance Analysis of ARM NEON Technology for Mobile Platforms},
  year      = {2011},
  isbn      = {9781450310871},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2103380.2103401},
  doi       = {10.1145/2103380.2103401},
  abstract  = {Mobile platforms have compute-bound applications, which will be executed on top of ARM processors in many cases. For such applications, the use of the ARM NEON technology should be considered since it can significantly increase the computing power of the underlying processor for vector operations. The ARM NEON technology is a media processing architecture based on SIMD (Single Instruction Multiple Data) that adds instructions targeted primarily for audio, video, and 3-D graphics processing. In this paper, we evaluate the ARM NEON technology in ARM Cortex-A8 processor for several open-source applications. To do this, we use the auto-vectorization feature of the ARM GCC compiler, which is implemented with the NEON technology. The evaluation criteria include program code size, execution time and power consumption, which are crucial in most embedded systems.},
  booktitle = {Proceedings of the 2011 ACM Symposium on Research in Applied Computation},
  pages     = {104–106},
  numpages  = {3},
  keywords  = {SIMD, NEON technology, embedded system, ARM cortex-A8, mobile platform},
  location  = {Miami, Florida},
  series    = {RACS '11}
}

@inproceedings{webassembly-survey,
  author    = {Musch, Marius
and Wressnegger, Christian
and Johns, Martin
and Rieck, Konrad},
  editor    = {Perdisci, Roberto
and Maurice, Cl{\'e}mentine
and Giacinto, Giorgio
and Almgren, Magnus},
  title     = {New Kid on the Web: A Study on the Prevalence of WebAssembly in the Wild},
  booktitle = {Detection of Intrusions and Malware, and Vulnerability Assessment},
  year      = {2019},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {23--42},
  abstract  = {WebAssembly, or Wasm for short, is a new, low-level language that allows for near-native execution performance and is supported by all major browsers as of today. In comparison to JavaScript it offers faster transmission, parsing, and execution times. Up until now it has, however, been largely unclear what WebAssembly is used for in the wild. In this paper, we thus conduct the first large-scale study on the Web. For this, we examine the prevalence of WebAssembly in the Alexa Top 1 million websites and find that as many as 1 out of 600 sites execute Wasm code. Moreover, we perform several secondary analyses, including an evaluation of code characteristics and the assessment of a Wasm module's field of application. Based on this, we find that over 50 {\%} of all sites using WebAssembly apply it for malicious deeds, such as mining and obfuscation.},
  isbn      = {978-3-030-22038-9}
}



% On the Use of Web Assembly in a Serverless Context
@inproceedings{10.1007/978-3-030-58858-8_15,
  author    = {Murphy, Se{\'a}n
and Persaud, Leonardas
and Martini, William
and Bosshard, Bill},
  editor    = {Paasivaara, Maria
and Kruchten, Philippe},
  title     = {On the Use of Web Assembly in a Serverless Context},
  booktitle = {Agile Processes in Software Engineering and Extreme Programming -- Workshops},
  year      = {2020},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {141--145},
  abstract  = {This paper considers how WASM can be run in different serverless contexts. A comparison of different serverside WASM runtime options is considered, specifically focused on wasmer, wasmtime and lucet. Next, different options for running WASM within two serverless platforms -- Openwhisk and AWS Lambdai -- are compared. Initial results show that a solution which uses the built-in node.js WASM supports is found to work better than using the dedicated WASM runtimes but this has limitations and providing more direct integration with WASM runtimes should be explored further.},
  isbn      = {978-3-030-58858-8}
}

% Valgrind
@inproceedings{valgrind-paper,
  author    = {Nethercote, Nicholas and Seward, Julian},
  title     = {Valgrind: A Framework for Heavyweight Dynamic Binary Instrumentation},
  year      = {2007},
  isbn      = {9781595936332},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1250734.1250746},
  doi       = {10.1145/1250734.1250746},
  abstract  = {Dynamic binary instrumentation (DBI) frameworks make it easy to build dynamic binary analysis (DBA) tools such as checkers and profilers. Much of the focus on DBI frameworks has been on performance; little attention has been paid to their capabilities. As a result, we believe the potential of DBI has not been fully exploited.In this paper we describe Valgrind, a DBI framework designed for building heavyweight DBA tools. We focus on its unique support for shadow values-a powerful but previously little-studied and difficult-to-implement DBA technique, which requires a tool to shadow every register and memory value with another value that describes it. This support accounts for several crucial design features that distinguish Valgrind from other DBI frameworks. Because of these features, lightweight tools built with Valgrind run comparatively slowly, but Valgrind can be used to build more interesting, heavyweight tools that are difficult or impossible to build with other DBI frameworks such as Pin and DynamoRIO.},
  booktitle = {Proceedings of the 28th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  pages     = {89–100},
  numpages  = {12},
  keywords  = {dynamic binary instrumentation, Memcheck, shadow values, Valgrind, dynamic binary analysis},
  location  = {San Diego, California, USA},
  series    = {PLDI '07}
}

% Stack-based vs register based VM
@article{stack-and-register-vm,
  author     = {Shi, Yunhe and Casey, Kevin and Ertl, M. Anton and Gregg, David},
  title      = {Virtual Machine Showdown: Stack versus Registers},
  year       = {2008},
  issue_date = {January 2008},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {4},
  number     = {4},
  issn       = {1544-3566},
  url        = {https://doi.org/10.1145/1328195.1328197},
  doi        = {10.1145/1328195.1328197},
  abstract   = {Virtual machines (VMs) enable the distribution of programs in an architecture-neutral format, which can easily be interpreted or compiled. A long-running question in the design of VMs is whether a stack architecture or register architecture can be implemented more efficiently with an interpreter. We extend existing work on comparing virtual stack and virtual register architectures in three ways. First, our translation from stack to register code and optimization are much more sophisticated. The result is that we eliminate an average of more than 46% of executed VM instructions, with the bytecode size of the register machine being only 26% larger than that of the corresponding stack one. Second, we present a fully functional virtual-register implementation of the Java virtual machine (JVM), which supports Intel, AMD64, PowerPC and Alpha processors. This register VM supports inline-threaded, direct-threaded, token-threaded, and switch dispatch. Third, we present experimental results on a range of additional optimizations such as register allocation and elimination of redundant heap loads. On the AMD64 architecture the register machine using switch dispatch achieves an average speedup of 1.48 over the corresponding stack machine. Even using the more efficient inline-threaded dispatch, the register VM achieves a speedup of 1.15 over the equivalent stack-based VM.},
  journal    = {ACM Trans. Archit. Code Optim.},
  month      = jan,
  articleno  = {2},
  numpages   = {36},
  keywords   = {register architecture, stack architecture, Interpreter, virtual machine}
}

  
@inproceedings{numba,
  author    = {Lam, Siu Kwan and Pitrou, Antoine and Seibert, Stanley},
  title     = {Numba: A LLVM-Based Python JIT Compiler},
  year      = {2015},
  isbn      = {9781450340052},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2833157.2833162},
  doi       = {10.1145/2833157.2833162},
  abstract  = {Dynamic, interpreted languages, like Python, are attractive for domain-experts and scientists experimenting with new ideas. However, the performance of the interpreter is often a barrier when scaling to larger data sets. This paper presents a just-in-time compiler for Python that focuses in scientific and array-oriented computing. Starting with the simple syntax of Python, Numba compiles a subset of the language into efficient machine code that is comparable in performance to a traditional compiled language. In addition, we share our experience in building a JIT compiler using LLVM[1].},
  booktitle = {Proceedings of the Second Workshop on the LLVM Compiler Infrastructure in HPC},
  articleno = {7},
  numpages  = {6},
  keywords  = {LLVM, Python, compiler},
  location  = {Austin, Texas},
  series    = {LLVM '15}
}

@inproceedings{mcsaf,
  author    = {Doherty, Jesse and Hendren, Laurie},
  title     = {McSAF: A Static Analysis Framework for {MATLAB}},
  year      = {2012},
  isbn      = {9783642310560},
  publisher = {Springer-Verlag},
  address   = {Berlin, Heidelberg},
  url       = {https://doi.org/10.1007/978-3-642-31057-7_7},
  doi       = {10.1007/978-3-642-31057-7_7},
  abstract  = {Matlab is an extremely popular programming language used by scientists, engineers, researchers and students world-wide. Despite its popularity, it has received very little attention from compiler researchers. This paper introduces McSaf, an open-source static analysis framework which is intended to enable more compiler research for Matlab and extensions of Matlab. The framework is based on an intermediate representation (IR) called McLast, which has been designed to capture all the key features of Matlab, while at the same time being simple for program analysis. The paper describes both the IR and the procedure for creating the IR from the higher-level AST. The analysis framework itself provides visitor-based traversals including fixed-point-based traversals to support both forwards and backwards analyses. McSaf has been implemented as part of the McLab project, and the framework has already been used for a variety of analyses, both for Matlab and the AspectMatlab extension.},
  booktitle = {Proceedings of the 26th European Conference on Object-Oriented Programming},
  pages     = {132–155},
  numpages  = {24},
  location  = {Beijing, China},
  series    = {ECOOP'12}
}

@inproceedings{cytron-ssa,
  author    = {Cytron, R. and Ferrante, J. and Rosen, B. K. and Wegman, M. N. and Zadeck, F. K.},
  title     = {An Efficient Method of Computing Static Single Assignment Form},
  year      = {1989},
  isbn      = {0897912942},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/75277.75280},
  doi       = {10.1145/75277.75280},
  booktitle = {Proceedings of the 16th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  pages     = {25–35},
  numpages  = {11},
  location  = {Austin, Texas, USA},
  series    = {POPL '89}
}

@article{tarjan-fast-dominator,
  author     = {Lengauer, Thomas and Tarjan, Robert Endre},
  title      = {A Fast Algorithm for Finding Dominators in a Flowgraph},
  year       = {1979},
  issue_date = {July 1979},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {1},
  number     = {1},
  issn       = {0164-0925},
  url        = {https://doi.org/10.1145/357062.357071},
  doi        = {10.1145/357062.357071},
  abstract   = {A fast algorithm for finding dominators in a flowgraph is presented. The algorithm uses 
depth-first search and an efficient method of computing functions defined on paths in trees. A simple implementation of the algorithm runs in O(m log n) time, where m is the number of edges and n is the number of vertices in the problem graph. A more sophisticated implementation runs in O(mα(m, n)) time, where α(m, n) is a functional inverse of Ackermann's function.Both versions of the algorithm were implemented in Algol W, a Stanford University version of Algol, and tested on an IBM 370/168. The programs were compared with an implementation by Purdom and Moore of a straightforward O(mn)-time algorithm, and with a bit vector algorithm described by Aho and Ullman. The fast algorithm beat the straightforward algorithm and the bit vector algorithm on all but the smallest graphs tested.},
  journal    = {ACM Trans. Program. Lang. Syst.},
  month      = jan,
  pages      = {121–141},
  numpages   = {21}
}

@article{tarjan-fast-dominator-improved,
  title    = {Finding Dominators in Practice},
  volume   = {10},
  issn     = {1526-1719},
  url      = {http://jgaa.info/getPaper?id=119},
  doi      = {10.7155/jgaa.00119},
  language = {en},
  number   = {1},
  urldate  = {2021-05-14},
  journal  = {Journal of Graph Algorithms and Applications},
  author   = {Georgiadis, Loukas and Tarjan, Robert E. and Werneck, Renato F.},
  year     = {2006},
  pages    = {69--94}
}

@article{peephole-opt,
  author     = {McKeeman, W. M.},
  title      = {Peephole Optimization},
  year       = {1965},
  issue_date = {July 1965},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {8},
  number     = {7},
  issn       = {0001-0782},
  url        = {https://doi.org/10.1145/364995.365000},
  doi        = {10.1145/364995.365000},
  abstract   = {Redundant instructions may be discarded during the final stage of compilation by using a simple optimizing technique called peephole optimization. The method is described and examples are given.},
  journal    = {Commun. ACM},
  month      = jul,
  pages      = {443–444},
  numpages   = {2}
}

@article{alive,
  author     = {Lopes, Nuno P. and Menendez, David and Nagarakatte, Santosh and Regehr, John},
  title      = {Provably Correct Peephole Optimizations with Alive},
  year       = {2015},
  issue_date = {June 2015},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {50},
  number     = {6},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/2813885.2737965},
  doi        = {10.1145/2813885.2737965},
  abstract   = { Compilers should not miscompile. Our work addresses problems in developing peephole optimizations that perform local rewriting to improve the efficiency of LLVM code. These optimizations are individually difficult to get right, particularly in the presence of undefined behavior; taken together they represent a persistent source of bugs. This paper presents Alive, a domain-specific language for writing optimizations and for automatically either proving them correct or else generating counterexamples. Furthermore, Alive can be automatically translated into C++ code that is suitable for inclusion in an LLVM optimization pass. Alive is based on an attempt to balance usability and formal methods; for example, it captures---but largely hides---the detailed semantics of three different kinds of undefined behavior in LLVM. We have translated more than 300 LLVM optimizations into Alive and, in the process, found that eight of them were wrong. },
  journal    = {SIGPLAN Not.},
  month      = jun,
  pages      = {22–32},
  numpages   = {11},
  keywords   = {Compiler Verification, Peephole Optimization, Alive}
}

@inproceedings{alive-in-lean,
  author    = {Juneyoung Lee and
               Chung{-}Kil Hur and
               Nuno P. Lopes},
  editor    = {Isil Dillig and
               Serdar Tasiran},
  title     = {AliveInLean: A Verified {LLVM} Peephole Optimization Verifier},
  booktitle = {Computer Aided Verification - 31st International Conference, {CAV}
               2019, New York City, NY, USA, July 15-18, 2019, Proceedings, Part
               {II}},
  series    = {Lecture Notes in Computer Science},
  volume    = {11562},
  pages     = {445--455},
  publisher = {Springer},
  year      = {2019},
  url       = {https://doi.org/10.1007/978-3-030-25543-5\_25},
  doi       = {10.1007/978-3-030-25543-5\_25},
  timestamp = {Fri, 27 Mar 2020 08:45:57 +0100},
  biburl    = {https://dblp.org/rec/conf/cav/LeeHL19.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}