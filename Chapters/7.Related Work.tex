\chapter{Related Work}

In the previous chapters, we present the SableWasm and evaluate its performance against several well-known benchmark suites. SableWasm is not the only WebAssembly runtime environment system that allows sandboxed WebAssembly modules to run outside the browser. This chapter will provide a quick overview of several existing  WebAssembly host environment implementations. Also, in the current SableWasm, we do not implement any auto-vectorization algorithms and heavily depend on LLVM, both in the frontend WASI-enable Clang compiler and the SableWasm backend, to generate parallel code.  Auto-vectorization is one of the key research fields in compiler optimization, and much research has been devoted to the field. Therefore, we will also briefly cover the auto-vectorization in LLVM in this chapter.

\section{WebAssembly runtime environments}

In chapter 6, we mentioned two WebAssembly runtime environments developed by the community, Wasmtime and Wasmer. Wasmtime perhaps is the earliest non-browser WebAssembly runtime environment. It started as a side project during WebAssembly standardization and is maintained by Bytecode Alliance\footnote{Bytecode Alliance: \url{https://bytecodealliance.org/}}. This cross-industry nonprofit organization focuses on extending WebAssembly and WASI beyond the browser and IoT devices. Wasmtime is built on the Cranelift compiler framework\footnote{Cranelift:\url{https://github.com/bytecodealliance/cranelift}}. Cranelift is similar to LLVM, providing a target-independent intermediate representation that eventually translates to native executable machine code. Currently, at the time of thesis writing, Cranelift is still at very early stages and only supports the x86-64 target. Although the Cranelift started as the backend for Wasmtime, it is not limited to the Wasmtime project. In the future, Cranelift may replace the fast debug backend in the Rust compiler toolchain and the Javascript/WebAssembly engine backend in SpiderMonkey.

Wasmer \footnote{Wasmer:\url{https://wasmer.io/}} is another WebAssembly runtime environment and maintained by a startup company. Wasmer shares many similarities comparing to Wasmtime. However, it is more flexible in design. Currently, Wasmer has three different backends, LLVM, Cranelift and a single-pass compiler for fast code generation. Additionally, comparing to Wasmtime, Wasmer is more aggressive in adding features to WebAssembly. For example, Wasmtime only supports WASI as the system interface API, while Wasmer supports both WASI and Emscripten specification. Wasmer also comes with a package manager, called WebAssembly Package Manager (WAPM) \footnote{WebAssembly Package Manager (WAPM): \url{https://wapm.io/}} which distributed pre-compiled sandboxed WebAssembly binary modules for various applications.

Wasmtime and Wasmer are both just-in-time (JIT) WebAssembly runtime environments. There are also ahead-of-time (AOT) compilers for WebAssembly modules. The most notable one is perhaps the Lucet compiler. Lucet\footnote{Lucet: \url{https://github.com/bytecodealliance/lucet}} is developed by Fastly and shares a similar design as SableWasm. The initial motivation for Lucet is to create a cloud application system that hosts user-uploaded WebAssembly modules. The Lucet compiler system has two parts, the Lucet shared library compiler, and the Lucet shared library loader. The Lucet shared library compiler compiles WebAssembly modules into shared libraries, while Lucet shared library load dynamically loads the shared library and executes the entry function, \texttt{\_start}. Unlike SableWasm, Lucet is also built on the Cranelift compile framework, similar to Wasmtime.

In this chapter we metioned

\section{Auto-vectorization}