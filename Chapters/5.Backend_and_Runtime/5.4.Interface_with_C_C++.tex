\section{Interface with C/C++}
The last section of the chapter will cover the interface between the generated shared library and the host languages. Currently, SableWasm only has a binder library for C/C++. However, the principle is relatively straightforward, and one can add implements binder function for any other languages. In the rest of the section, we will focus our discussion on the callee wrapper, WASI function implementations and error handling strategies.

\paragraph{Callee wrapper}
Section 5.2 mentioned that SableWasm stores function instance as a pair of context pointer and function address pointer. Additionally, SableWasm also encodes the function types as null-terminated strings. However, all this information is only available to the host program at runtime. C/C++ is a statically typed language; hence, we can only specify type contracts on the exported functions at compile-time and verify the contracts at runtime. Traditionally, one can use a type erased pointer, a \texttt{void} pointer, to store the function address and reinterpret it to the actual concrete type.  SableWasm presents a helper class that provides type-safe access to the exported functions, \texttt{WebAssemblyCallee}. \texttt{WebAsssemblyCallee} takes advantage of the template metaprogramming system in C++ and generates null-terminated encoding of expected type at compile-time. At runtime, the wrapper class will check the type signature string against the actual type string before forwarding the function call. If the type signature string mismatch, the system will signal an exception.

\paragraph{WASI interface implementation}
WebAssembly System Interface (WASI) extends the WebAssembly by providing syscalls that interact with the host environment. This extension is non-invasive, and all the syscalls are in the form of imported functions, mainly host functions. Hence, SableWasm implements the WASI extension using host library functions only. At the shared library initialization phase, the loader will set up WASI host functions based on the import descriptor. Currently, SableWasm only implements minimal WASI interface functions to run benchmarks, such as standard I/O and timing. However, the framework is easy to extend, and all the WASI function implementations are under the namespace \texttt{runtime::wasi}. Therefore, we will skip them in detail in the thesis; one can consult the source code for implementation detail of WASI interface functions. One of the project's future work is to continuously work on the WASI system interface and add more features to SableWasm, such as capability-based file system and networking.

\paragraph{Error handling strategies}
The last topic we will in the section is error handling. There are multiple candidates for SableWasm error handling strategies. The most straightforward one is to perhaps using error code as return values. However, this adds unnecessary complexity to the generated code and does not play well with the future WebAssembly exception handling extension \footnote{WebAssembly exception handling: \url{https://github.com/WebAssembly/exception-handling}}. The second choice is to use `long-jump' provided by C standard library. This method is quite interesting; however, it does not work well with a multi-instance host system, and especially hard to get it correct in a multi-threaded system. Hence, SableWasm implements the error handling strategies using the C++ exception-based system. One may notice that the generated shared libraries do not create any runtime exceptions by themselves. Instead, all runtime exceptions come from the library's built-in functions. Hence, the SableWasm backend code generator does not need to worry about exception handling when lowering SableWasm MIR to LLVM intermediate representation. Further, all WebAssembly values are simple numeric values; hence, the destructors for all of them are trivial. Therefore, SableWasm depends on C++'s unwind library to perform the stack unwinding correctly.