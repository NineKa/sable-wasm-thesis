\section{Code Generation}

This section describes the code generation strategy used in the SableWasm LLVM backend. For most of the instructions, especially for SableWasm MIR numeric operations, the translation rules are simple mapping between SableWasm MIR instructions to their LLVM counterparts. In this section, we will skip the discussion over these trivial mapping. Instead, one can consult the SableWasm source code for more details. The rest of the section will focus on several key aspects, such as local variable implementation, linear memory manipulation, indirect function call, and SIMD instruction operations. One problem that arises when lowering SableWasm MIR into LLVM intermediate representation is how to pick the instruction translation order. Any instruction in SableWasm MIR can refer to values either generated by a previous instruction in the same basic block or instruction within a dominating block, implying that when lower SableWasm MIR, we need to perform a pre-order tree traversal over the dominator tree. However, Phi nodes only require the candidate value came from a single inward flow instead of dominating the enclosing basic block. Hence, the translation visitor may not have translated the candidate value before Phi nodes. SableWasm backend takes a two-phase translation to address this problem. In the first pass, the backend will translate all the instructions and collect the resulting values into a map, and in the second pass, the backend will come back to the Phi Nodes add setting up the candidate values accordingly.

\paragraph{Function declaration and local variables} \quad
\begin{lstlisting}[basicstyle=\linespread{1}\small\ttfamily, language=LLVM, mathescape=true]
function %foo: [i32] -> [f32] {
  {(arg) %local0: i32, %local1: f64} 
  ......
}
$\Longrightarrow$
define private i32 @foo(%__sable_instance_t* %0, i32 %1) {
entry:
  %2 = alloca i32, align 4
  store i32 %1, i32* %2, align 4
  %3 = alloca double, align 8
  store double 0.000000e+00, double* %3, align 8
  ......
}

{%local: i32} 
%t0 = local.get %local $\Longrightarrow$ %t0 = load i32, i32* %local, align 4
local.set %local %t0 $\Longrightarrow$ store i32 %t0, i32* %local, align 4
\end{lstlisting}
