\chapter{Middle-level Intermediate Representation}

This chapter describes SableWasm's middle-level intermediate representation
(MIR), which has a critical role in the entire compilation pipeline. The MIR
acts as a middle ground between the WebAssembly bytecode frontend and various
possible backends. Currently SableWasm only implements one backend that utilizes
the LLVM compilation framework, but adding more backend support should not
require significant modification on the MIR. It also implements an analysis and
transformation framework where we perform several optimizations over the MIR. We
will first go over the overall design of the MIR, then later move to the
translation strategy we used to translate WebAssembly bytecode to MIR. Finally,
we will end the chapter with several analyses and transformations we
implemented.

\section{MIR Design}

In the previous chapters, we covered the design of WebAssembly bytecode. A quick
reminder, WebAssembly is a stack-based intermediate representation (IR) where
all instructions operate over an implicitly declared operand stack. There are
several advantages of a stack-based IR. Perhaps the most important one is its
portability. A stack-based IR makes fewer assumptions on the machine than a
register-based one. One can even provide an implementation for a hypothetical
machine with only one register. Another advantage is the code size. Experiments
show that, in general, a stack-based IR is smaller in size than its
corresponding registered version \cite{stack-and-register-vm}. When designing a
binary format that ships executables over the internet, the stack-based IR seems
to be a better choice for WebAssembly.

Nevertheless, there are no silver bullets: a stack-based IR design also has its
drawbacks. One of them is the difficulty faced when performing code analysis and
transformation over the module. As for each instruction, its operands implicitly
come from the stack; the value use-definition relationship between instructions
is not apparent to the analysis, and recovering such connection between
instructions from the IR is not a trivial task.

\begin{figure}
    \centering
    \lstinputlisting[
        language=SableWasmMIR,
        basicstyle=\linespread{0.8}\ttfamily,
        numbers=left
    ]{Code/4.MIR/fibonacci.mir}
    \caption{Fibonacci in translated SableWasm MIR}
    \label{fig:mir-fibonacci}
\end{figure}

On the other hand, we have the register-based intermediate representation,
commonly abstracted to assume an infinite number of registers and requiring a
register allocation algorithm to map them to actual, physical registers. For
each instruction in register-based IR, it has its operand encoded in the
instruction. Hence, the use-definition relationship will become explicit to the
analysis and transformation.

The main design goal for SableWasm MIR is to provide an analysis platform for
the entire compiler system. Thus, we implement our MIR as an infinite register
machine. We also take a traditional approach in various other aspects. For
example, instead of using the structured control flow similar to what
WebAssembly offers, we use \emph{control-flow graphs} (CFGs) to represent the
relationship between basic blocks. The SableWasm MIR is also in
\emph{single static assignment} (SSA) form \cite{ibm-ssa}, as covered in the
background chapter. The design for instruction and module-level entities in
SableWasm MIR is quite similar to what WebAssembly instruction offers. One can
view the SableWasm MIR as a mixture of the target LLVM intermediate
representation and the source WebAssembly bytecode. We also adopt several design
features from LLVM IR into MIR, such as automatically managed use-site lists,
which provide each AST node with an efficient way to access their use sites.
In SableWasm MIR, all elements are derived from the base class \texttt{ASTNode}
which implements these features that are helpful later in MIR analysis and
transformation.

Figure~\ref{fig:mir-fibonacci} shows a simple function that calculates Fibonacci
numbers with a recursive method in SableWasm MIR. With the help of the figure,
we will go through the detailed design of SableWasm later in the chapter. We
will first present the module-level entity design and their initializer
expressions, such as functions, then move to the design of each instruction
defined in MIR.

\input{Chapters/4.MIR/4.1.1.Module Entities}
\input{Chapters/4.MIR/4.1.2.Initializer Expr}
\input{Chapters/4.MIR/4.1.3.Instructions}

\section{Translating WebAssembly to MIR}

In this section, we will cover the translation between WebAssembly bytecode and SableWasm MIR. We have covered the design of SableWasm MIR instructions previously. One may notice that for most of the instructions, especially for the numerical operations, SableWasm MIR shares the same semantics as WebAssembly. Hence, the translation rules for these instructions are pretty trivial, and we will not cover them in detail in this section. Instead, this section will focus on the translation rules for the structured control flow construct and WebAssembly instructions that require reduction during translation.

The translation framework is similar to the validation framework we discussed in the previous chapter except for two significant differences. First, the operation stack will keep track of the values generated during translation instead of types. Let's take \texttt{i32.add} as an example. \texttt{i32.add} instruction takes two values from the stack and then performs 32-bit integer addition between them. Finally, it will push the result type back onto the stack. In the case of translation stack, we pop two values from the stack and assume they are 32-bit integers. In SableWasm MIR, we use pointers to instructions to refer to the values generated by them. Then, the translation visitor will build a \texttt{IntBinaryOp} instruction, with \texttt{Add} as opcode, and two pointers as operands. Finally, the visitor will append the instruction to the current active basic block and push the instruction pointer of \texttt{IntBinaryOp} onto the stack. Another difference between the validation framework and the translation framework is the labels stack. In the validation framework, the labels stack stores the resulting types generated from the label. In the translation framework, the labels stack stores the potential landing basic blocks for the labels. We will revisit this with more details later in this section.

\input{Chapters/4.MIR/4.2.1.Structured-Control-Flow Construct}
\input{Chapters/4.MIR/4.2.2.Instructions_Reduction}

\section{Analysis Framework}
\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{Images/4.MIR/analysis-framework.pdf}
    \caption{SableWasm MIR Analysis and Optimization Framework}
    \label{fig:sablewasm-mir-analysis-framework}
\end{figure}
SableWasm also implements an analysis and optimization framework over middle-level intermediate representation (MIR). The framework consists of two parts, passes and drivers. SableWasm analysis and transformation framework only provides essential support for managing passes, compared to other more advanced frameworks, such as McSAF\cite{mcsaf}, an optimization framework for MATLAB language. Figure~\ref{fig:sablewasm-mir-analysis-framework} illustrates the current state of the framework in SableWasm. Currently, we implement three different drivers. \texttt{SimpleModulePassDirver} accepts module passes and operates on the module level. At the time of thesis writing, we haven't explored the inter-procedure analysis for SableWasm MIR in detail, and the only module pass implemented is the pretty print pass. In the future, one can add inter-procedure analysis to SableWasm, by implementing the \texttt{ModulePass} interface. The second driver is the \texttt{SimpleFunctionPassDriver}. As its name suggests, it manages \texttt{FunctionPass} instead. \texttt{FunctionPass} implements intra-procedural analysis that operates over basic blocks. SableWasm currently implements multiple intra-procedural analyses, such as dominator tree construction and local variable numbering. We will cover these passes in detail in this section. The last driver in SableWasm is \texttt{SimpleForEachFunctionPassDriver} which is a wrapper class for \texttt{SimpleFunctionPassDriver}. It works with \texttt{FunctionPass} but takes module as argument. It will apply the pass for each function within the module and terminates if they reach a fixpoint. McSAF manages the analysis result for the passes and automatically detects if the analysis reaches fixpoint. SableWasm analysis framework requires more manual work when designing passes and requires passes to report whether they have reached fixpoint to the driver correctly via pass's return value.

\input{Chapters/4.MIR/4.3.1.Dominators_and_Dependence}
\input{Chapters/4.MIR/4.3.2.Control-Flow_Graph_Simplification}
\input{Chapters/4.MIR/4.3.3.Type_Infer}
\input{Chapters/4.MIR/4.3.4.Redundant_Local_Variable_Elimination}