\chapter{Middle-level Intermediate Representation}

This chapter describes SableWasm's middle-level intermediate representation (MIR), which has a critical role in the entire compilation pipeline. MIR acts as a middle ground between the WebAssembly bytecode frontend and various possible backend. SableWasm only implements one backend that currently utilizes the LLVM compilation framework, but adding more backend support should not require significant modification on the MIR. It also implements an analysis and transformation framework where we perform several optimizations over the MIR. We will first go over the overall design of the MIR, then later move to the translation strategy we used to translate WebAssembly bytecode to MIR. Finally, we will end the chapter with several analyses and transformations we implemented.

\section{MIR Design}

In the previous chapters, we have quickly covered the design of WebAssembly bytecode. A quick reminder, WebAssembly is a stack-based intermediate representation (IR) where all instructions operate over an implicitly declared operand stack. There are several advantages of stack-based IR. Perhaps the most important one is its portability. A stack-based IR makes fewer assumptions on the machine than a register-based one.  One can even provide an implementation for a hypothetical machine with only one register. Another advantage is the code size. Experiments show that, in general, stack-based IR is relatively more minor in size than its corresponding registered version \cite{stack-and-register-vm}. When designing a binary format that ships executables over the internet, the stack-based IR seems to be a better choice for WebAssembly.

Nevertheless, there are no silver bullets; stack-based IR design has its drawbacks. One of them is the difficulty when performing code analysis and transformation over the module. As for each instruction, its operands implicitly come from the stack; the value use-def relationship between instructions is not apparent to the analysis, and recover such connection between instructions from the IR is not a trivial task.

\begin{figure}
  \centering
  \lstinputlisting[language=C, basicstyle=\small, numbers=left]
  {Code/4.MIR/fibonacci.mir}
  \caption{Fibonacci in translated SableWasm MIR}
  \label{fig:mir-fibonacci}
\end{figure}

On the other hand, we have the register-based intermediate representation, more specifically, the infinite-register machine. The infinite-register machine is similar to what one would expect from an actual physical machine. The only difference that the infinite-register machine, as the name suggests, has an infinite amount of registers. For each instruction in register-based IR, it has its operand encoded in the instruction. Hence, the use-definition relationship will become explicit to the analysis and transformation. The main design goal for SableWasm MIR is to provide an analysis platform for the entire compiler system. Thus, we implement our MIR as an infinite register machine. We also take a traditional approach in various other aspects. For example, instead of using the structured control flow similar to what WebAssembly offers, we use control-flow graphs (CFGs) to represent the relationship between basic blocks. The SableWasm MIR is also in single static assign (SSA) form \cite{ibm-ssa}, covered in the background chapter. The design for instruction and module-level entities in SableWasm MIR is quite similar to what WebAssembly instruction offers. One can view the SableWasm MIR as a mixture of LLVM intermediate representation and WebAssembly bytecode. We also adopt several design features from LLVM IR into MIR, such as use site lists. In SableWasm MIR, all elements are derived from the base class \texttt{ASTNode} which offers the implementation to these features. The base class automatically manages the use sites list, which is helpful later in MIR analysis and transformation. 

Figure~\ref{fig:mir-fibonacci} shows a simple function that calculates Fibonacci numbers with a recursive method in SableWasm. With the help of the figure, we will go through the detailed design of SableWasm later in the chapter. We will first present the module-level entity design and their initializer expressions, such as functions, then move to the design of each instruction defined in MIR.

\input{Chapters/4.MIR/4.1.1.Initializer Expr}
\input{Chapters/4.MIR/4.1.2.Module Entities}
\input{Chapters/4.MIR/4.1.3.Instructions}


\section{Translating WebAssembly to MIR}

\subsection{Structured-Control-Flow Construct}

\subsection{Instructions Reduction}

\section{Analysis Framework}

\subsection{Type Infer}

\subsection{Dominators and Dependence}

\subsection{Local Value Numbering}

\subsection{Control-Flow Graph Simplification}

\subsection{Redundant Local Variable Elimination}