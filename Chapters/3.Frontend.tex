\chapter{Frontend}

This chapter describes the frontend of SableWasm. The front end consists of two parts, the bytecode parser and validation pass.  WebAssembly is a continuously evolving language, and its community might add new instructions in the future. Hence, the parser and the bytecode validation phase's design closely follow WebAssembly's specification and modular to ensure the framework's extensibility. A read-only view of the module structure provides additional functionality. The parser and validation phase design focuses on performance, both in execution time and memory footprint. 

\section{Bytecode Parser}
One of WebAssembly's binary format design goals is simple to parse. Although there are existing open-source bytecode parsing and validation library available when writing the thesis, such as WABT \footnote{WebAssembly Binary Toolkit: \url{https://github.com/WebAssembly/wabt.git}} provided by the WebAssembly community, there is no suitable library at the time when the project starts. Thus, for SableWasm, we implement our bytecode parsing frontend instead. The bytecode parser consists of three components, byte-source reader, WebAssembly bytecode parser and parser delegate. This section will give a brief description of each component, and figure~\ref{fig:sablewasm-parser} presents a general illustration of the parser's design.  

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{Images/sablewasm-parser.pdf}
  \caption{A illustration of SableWasm parser}
  \label{fig:sablewasm-parser}
\end{figure}

\paragraph{Byte-source Reader}
The byte-source reader consists of two parts, a byte-buffer reader and a WebAssmebly reader. The byte-buffer reader provides essential functionalities such as read and skips. Additionally, the byte-buffer reader also needs to support rewind and barrier. Any out of bound access, either beyond the barrier or byte stream exhausted, the byte-buffer reader will signal via exceptions. On the other hand, the WebAssembly reader provides a richer interface to the parser, such as decode LEB-128 encoded integers and parsing WebAssembly value types. The WebAssembly reader is also responsible for validating the result before passing it to the parser. In the case the result is invalid, the reader throws exceptions similar to the byte-buffer reader.

\paragraph{WebAssembly Parser}
WebAssembly parser is the kernel part of the parsing framework. As we discussed earlier in the chapter, one of the primary design goals of the framework is its extensibility. Hence, the SableWasm parser is modular and consists of three parts, parser core, custom section parser and instruction extension parser. The grammar for WebAssembly binary representation is quite simple, and therefore, the parser core implements a simple top-down recursive descent parser with a single byte look-ahead.

\emph{Custom sections} are a special section defined in the WebAssembly standard. They are essentially a binary data chunk tagged with a string name. How to interpret the binary data is different from one to another. These custom sections can either be standardized by the community or defined specific to a toolchain. In this project, we implement two custom sections standardized by the WebAssembly working group, namely \emph{Name} section and \emph{Producer} section. The \emph{Name} section gives human-readable names to functions and their local variables that help program debugging. The specification does not require these names to be the same as the import or export names. There is no direct support for more detailed debug information encoding in WebAssembly, at the time of thesis writing. However, extensions are working on this problem, such as DWARF for WebAssembly \footnote{DWARF for WebAssembly: \url{https://yurydelendik.github.io/webassembly-dwarf/}}; on the other hand, the \emph{Producer} section is relatively simple. It only encodes the information about the toolchain that generates the module, such as the toolchain name and version. All custom section parsers in SableWasm derived from the base class \texttt{CustomSection}. The parser core will dispatch the binary chunk to search custom section parser based on the name tag. Each custom section parser manages its results and does not communicate to the parser delegate directly. 

Instruction extension parsers focus on another different aspect of the WebAssembly module. In the background section, we have visited several extensions that merged to the WebAssembly specification. A quick reminder, WebAssembly extensions can insert or modify the instructions defined in the minimum-viable-product (MVP)  specification. The SableWasm WebAssembly parser employs instruction extension parsers to address this problem. When the parser intends to parse an instruction, it will iterate over all its instruction extension parsers in a chained manner. If the instruction opcode is not recognized by any registered instruction extension parser nor in the minimum-viable-product specification, the parser will signal the error by throwing an exception. An instruction extension parser can also override the default behaviour for MVP instructions by handling the instruction early, though, in the current version of WebAssembly, no extensions modify the semantics of these instructions. In this project, we implement two instruction extension parsers, the Non-trapping-float-to-int conversion parser and SIMD parser, which handles the instructions introduced by the extensions as their names suggest.

\paragraph{Parser Delegate} The last part of the SableWasm WebAssembly bytecode parser is the parser delegate. The parser delegate and parser are direct implementations of the common delegation patterns seen in many other projects, separating the parsing from the heavy lifting of module construction. One can implement a validation pass at this level without module construction. However, in this project, we implement our bytecode validation pass after the module construction, giving space for further projects focusing on bytecode-level transformation. We will discuss the implementation of such validation pass later in the chapter. 

In this section, we give a brief overview of the parser framework introduced in the SableWasm. In the next section, we will discuss the WebAssembly bytecode representation used in the project and several techniques to improve the performance and ensure flexibility.

\section{WebAssembly Bytecode Representation}

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{Images/sablewasm-bytecode.pdf}
  \caption{A illustration of SableWasm Bytecode Representation}
  \label{fig:sablewasm-bytecode}
\end{figure}

WebAssembly specification provides a compact and representation in both binary format, and text format \cite{10.1145/3062341.3062363}, and these specifications might subject to change in the future. In SableWasm, we implement our bytecode representation as close to the specification as possible.  Hence, in the future, if the community alters the specification in the future, we can apply fixes to the bytecode representation in a straightforward manner without introducing extra complexity. In figure~\ref{fig:sablewasm-bytecode}, we present an illustration of the bytecode representation used in SableWasm. Compare to the representation given in the WebAssembly specification, the only difference we have is the function section. The standard WebAssembly bytecode representation actually splits the function section into two different sections, namely \emph{function} and \emph{code}, to achieve its one-pass validation goal. The \emph{function} section contains the type of all functions defined in the module, serving similar to function declarations in other languages. Later in the module, \emph{code} section defines them. On the other hand, in SableWasm, we merge these two sections into a single function section. A function in SableWasm bytecode representation contains both its type and its definition.

\paragraph{WebAssmebly Module View} The WebAssembly module structure only serves as a storage container for the bytecode representation and itself does not provide an interface to the user, except retrieving entities by index. Additionally, WebAssembly standard binary format focuses more on compactness instead of usability, which leads to complexity when retrieving the information. For example, to avoid duplication, the function types are stored in their section, namely, \emph{type} section. Later in the module, any reference to the type becomes an indices respect to this section. Another example is entity indices. WebAssembly specification requires that every import entry in the \emph{import} section implicitly introduces an index in its corresponding class. These indices should come before any definition introduced in the module. These two rules suggest that to retrieve an entity by index, one should first iterate over all the imports and then locate the entity accordingly, which is a relatively expansive operation. To address these problems, we implement a read-only view of the WebAssembly module that cache the indices and provides additional features. 

\paragraph{Instructions} SableWasm takes a traditional `abstract syntax tree' approach to bytecode instruction representation. The frontend represents each instruction using a corresponding class derived from a common base class, namely \texttt{Instruction}, and an expression with a vector of instruction pointers. One observation is that the heap memory usage grows linearly respective to the size of the expression, which is not optimal. In WebAssembly, instructions operate over an implicitly defined stack, and for most of the operation, there is no operand attach to them. For example, \texttt{F32x4Nearest} has no operand, and it will pop a value from the stack, treat it as a vector of packed single-precision floating-point values, round them to the nearest integer, finally push the result back to the stack. From the bytecode representation point of view, there is no difference between one instruction without operand and another with the same opcode. Hence, to reduce memory consumption, we use pointers that point to object singleton to represent instruction without operand. However, how can we distinguish a pointer points to an object from one referring to a heap-allocated object which requires memory deallocation? To address this problem, we use tagged pointers. For a non-heap allocated singleton object, we tag the least significant bit in the pointer with zero; and on the other hand, we tag that of a heap-allocated object pointer with one. Later, within the destructor, we only need to exam the least significant bit of the pointer and perform memory de-allocated in the case when needed. With tagged pointer techniques, we can greatly reduce the memory needed to store the bytecode representations while maintaining their polymorphic nature. As less memory allocation is needed, we also observe performance improvement in terms of execution time, which we will later see in this chapter.

This section gives an overview of the bytecode representation used in SableWasm and several techniques to improve its performance. In the next section, we will move to the validation pass implementation in SableWasm.

\section{WebAssembly Bytecode Validation}

WebAssembly specification defines a  detailed validation rule both for well-formedness, and type-soundness \cite{10.1145/3167082}. Similar to the parser framework, we implement our validation pass as close to the specification as possible. If there are changes to the specification in the future, we can adopt them with minimal effort. The validation pass implementation consists of two parts, the validation context and validation visitor, implementing context and rules in the specification accordingly. 

\section{Performance Evaluation}

adsfadsf