\subsection{Redundant Local Variable Elimination}

\begin{figure}[ht]
    \lstinputlisting[
        basicstyle=\linespread{1}\small\ttfamily,
        language=SableWasmMIR,numbers=left
    ]{Code/4.MIR/memcpy.mir}
    \caption{Redundant local variable elimination example}
    \label{fig:redundant-local-elem}
\end{figure}

In this section, we are focusing on another common problem that appeared in translated WebAssembly programs. From the WebAssembly validation rule, one may notice that, in MVP, there is no way for instructions in a \texttt{block}, \texttt{if}, or \texttt{loop} to access values beyond their scope. MVP WebAssembly adopts this rule to simplify the validation rules and ensure the safety of the generated module. However, this leads to poor performance in generated code. The WebAssembly compiler needs to push them to the local pool first, and later load them from the pool to push values into the nested expression within the structured control-flow constructs. A non-optimized runtime implementation might emit a store operation to stack memory and a load operation to stack memory. Figure~\ref{fig:redundant-local-elem} demonstrate this problem with an concrete example. The code is selected from a two-dimensional matrix multiplication benchmark test in C programming language and compiled to WebAssembly with WASI enabled Clang compiler \footnote{WASI SDK: \url{https://github.com/WebAssembly/wasi-sdk}}. Here we turn off the multivalue extension to give a better understanding of the problem. The function implements the memory copy procedure, \texttt{memcpy}, that appears in the standard C library. Here we only present a small snippet of the entire function as the original function contains more than 600 instructions and does not fit the thesis length. But, the problem appears in numerous locations in the entire generated control-flow graph. Line 13 and line 18 in figure~\ref{fig:redundant-local-elem} contain a pair of redundant local variable load and store instructions. So, why do we have these redundant load and store instructions here? One may notice that \texttt{\%BB:2} is the condition block that generated in the translation pattern for \texttt{if} instruction, and \texttt{\%BB:3} is the false block for that \texttt{if} instruction. As in MVP WebAssembly, the only possible type for \texttt{if} instruction is \texttt{[i32] -> []}, which consume exactly only one value as condition from the operand stack. Hence, the additional value needs to be awkwardly pass through via the local pool, in this case, value \texttt{\%23}. A better control flow graph should eliminate this \texttt{LocalGet} instruction in line 18 by replacing with \texttt{\%23}, and even better the \texttt{LocalSet} at line \texttt{\%13} if there are no value depends on this store operation.

To address these problems, we implement the redundant local elimination that derived from the point-to analysis\cite{alias-sable, point-to-microsoft, point-to-survey}. The accurate full-scale point-to analysis is hard. In fact, the problem is undecidable \cite{point-to-undecidable}. Compared to the full-scale point to analysis, the SableWasm MIR redundant local variable elimination is relatively simple. First, we only have one layer of indirection. In a full-scale alias analysis, one might need to construct a graph to get the whole picture. In SableWasm's redundant local elimination analysis, we only have one layer of indirection, a value referring to a local variable. Second, there are no complex data construct in WebAssembly. Finally, one complicated problem in alias analysis is around \texttt{Call} instructions. In a full-scale point-to analysis, one needs to utilize inter-procedural analysis to compute the result accurately. However, in SableWasm MIR, the local variable is private to its enclosing function, and the local alias can only happen within the function. Thus, when performing the local variable alias analysis, we can safely assume the calls do not affect the result. The redundant local variable elimination analysis splits into three parts, local variable aliasing, local get elimination and local set elimination.

\paragraph{Local variable aliasing}
Local variable aliasing analysis is the first part of the redundant local variable elimination analysis, and it is a forward data-flow analysis. It computes the relationship between local variables and values. We will first go through the result representations in the analysis. We record the possible alias using pairs $\langle \%local, \%value \rangle$, indicating that $\%local$ may contain value of $\%value$. Additionally, we introduce a special value $\%zero$, referring to the implicit zero-initializer at the beginning of the function. The initialization for `In' sets is straightforward. We initialize its `In' set with all locals implicit initialized to zero for the entry block and empty for any other basic blocks. Initially,  any basic block except the entry block has no information on local variable aliasing, and later in the analysis, we will incrementally collect them. The formal definition for `In' sets initialization is as follows. Here we use $locals$ to denote all local variables defined in the function, and $BB_{entry}$ refers to the entry block.
\begin{align*}
    IN(BB_{entry}) & = \{ \langle x, \%zero \rangle : x \in locals \} &                                 \\
    IN(BB)         & = \{ \}                                          & \forall BB . BB \neq BB_{entry}
\end{align*}
Next is the merge operator for the analysis. The merge operation for the local variable aliasing is a simple union operator, as the data flow may come from any predecessor blocks. The last part of the analysis is the `Gen' set and `Kill' set for instructions. In local aliasing analysis, we only need to consider for \texttt{LocalSet} instructions as they are the only instructions that create a point-to relationship between local variables and values. For clarity, let's assume the \texttt{LocalSet} instruction is \texttt{local.set \%local \%value} which set the local variable $local$ with $value$. The `Gen' set for the instruction is quite straightforward, and it is $\langle local, value \rangle$. The `Kill' set is more interesting. It is the set of pairs that has local variable $local$ because, after a \texttt{LocalSet} instruction, any point-to relationships for this local variable are outdated. More formally,
\begin{align*}
    \bowtie(BB)                                   & =
    \bigcup_{pred \in Pred(BB)} OUT(BB)               \\
    GEN(\text{\textbf{local.set} } local\ value)  & =
    \{ \langle local, value \rangle\}                 \\
    KILL(\text{\textbf{local.set} } local\ value) & =
    \{ \langle local, v \rangle : \forall v \in values \}
\end{align*}
Here we use $values$ to denote the set of all available values within the control-flow graph. The stop criteria for the analysis are simple. If there are no more changes in the result sets, the local variable aliasing analysis will terminate. It's easy to show that the process will eventually complete. The size of all results sets is non-decreasing between iterations, and there is an upper bound for the set cardinality. In this paragraph, we present the local variable aliasing analysis we used in SableWasm MIR. It is closely related to the existing point-to analysis and aliasing analysis.

\paragraph{Local variable get elimination}
After we compute the relationship between local variables and the values, we can then start performing local variable eliminations. Here, we begin by iterating through all instructions, and for \texttt{LocalGet} instructions, we exam the local variable aliasing results at that point. If the aliasing is unique, we can proceed to the next step of elimination; otherwise, we will leave the \texttt{LocalGet} unchanged. If the aliasing refers to $\%zero$, we will replace the \texttt{LocalGet} instructions with a \texttt{Constant} instructions with zero value. On the other hand, if the aliasing refers to a unique value, we will replace any occurrence of \texttt{LocalGet}'s value with it. Note that this replacement does not violate the SSA form of the control-flow graph. Assume there is an instruction that refers to the value yield by \texttt{LocalGet}, then its enclosing basic block is either dominated by the \texttt{LocalGet}'s block, or that instruction is a Phi node. One may show that the unique point-to value must dominate the \texttt{LocalGet}'s block; otherwise, the local variable refers to more than one value. Thus, if we replace a dominating value with another dominating value, the SSA constraints still hold.

\paragraph{Local variable set and local variable elimination}
The last part of the analysis is the local variable set and local variable elimination. Once we finished the local variable get elimination, we can reduce these problems into dead-code elimination. SableWasm MIR consider a \texttt{LocalSet} instruction dead if the local variables has no \texttt{LocalGet} refers to it. One may notice that this problem is isomorphic to liveness analysis. Indeed, in SableWasm MIR, we perform a liveness analysis on local variables to determine which local variables are still alive based on the \texttt{LocalGet} instructions and perform dead \texttt{LocalSet} elimination based on the result. We will skip the details on liveness analysis here as they are quite standard in compiler implementations. One could consult the paper\cite{fast-liveness} for more details. Finally, we can perform dead local variable elimination. Compare to dead \texttt{LocalSet} elimination, removing redundant local variable is quite straightforward. We only need to iterate through the use-site list to check if there exists any reference to the local variable; if not, we remove the instruction from the function.