\subsection{Control-Flow Graph Simplification}

In section 4.2, we illustrate the translation rule from WebAssembly bytecode to SableWasm MIR. Unfortunately, the translation rules yield suboptimal control flow graphs. Hence, in this section, we will incrementally improve the control-flow graphs by fixing several obvious issues we found, such as trivial Phi nodes and unnecessary branching. The control-flow graph simplification also performs dead code elimination and unreachable basic block elimination. This section presents the patterns, along with their transforming strategies used in SableWasm. The general design of the simplification pass is similar to what one would expect in a peephole optimizer \cite{peephole-opt}. It iterates through the control-flow graph and scanning for matched patterns, and if it finds any optimization opportunities, it will apply transformation strategies immediately. In the future, one may generalize this simplification pass into a fully-featured peephole optimizer. More interestingly, one can design a domain-specific language for patterns similar to Alive \cite{alive, alive-in-lean} for LLVM to ensure extensibility and correctness of the patterns. The simplification pass will terminate if the execution reaches a fixed point, where there are no more optimization opportunities.

\paragraph{Trivial Phi nodes}
The first pattern we found in generated  SableWasm MIR is the trivial Phi nodes. Trivial Phi nodes refer to the Phi nodes with only one candidate value. In section 4.2.1. we present the translation patterns for \texttt{loop} instructions in WebAssembly and mentioned that the pattern is suboptimal and will result in trivial Phi nodes. A quick reminder, the \texttt{loop} instructions need to insert Phi nodes to the landing BB, which has determined non-merging control flow due to the limitation of the translation framework. To address this, we loop for \texttt{\%t0 = phi t [\%t1, \%path]} for all possible type $t$. The transform strategy is to replace all appearance of value \texttt{\%t0} with value \texttt{\%t1}. As the Phi nodes do not map to any operations and are only introduced by SSA to explicitly mark value merging, removing them from the control-flow graph does not change the semantics of the program. When replacing the values, SableWsam uses the use site lists managed by the \texttt{ASTNode} to boost the performance.

\begin{figure}
    \begin{minipage}[t]{.5\textwidth}
        \lstinputlisting[
            basicstyle=\linespread{0.9}\footnotesize\ttfamily,
            language=SableWasmMIR,numbers=left
        ]{Code/4.MIR/simplify-cfg.mir}
    \end{minipage}\hfill
    \begin{minipage}[t]{.5\textwidth}
        \lstinputlisting[
            basicstyle=\linespread{0.9}\footnotesize\ttfamily,
            numbers=left
        ]{Code/4.MIR/simplify-cfg.wat}
    \end{minipage}
    \caption{Control-flow graph simplification example}
    \label{fig:simplify-example}
\end{figure}

\paragraph{Redundant branching}
The second pattern focus on redundant branching. These redundant branching also come from the translation patterns for structured control flow. One may already notice that we will always generate a landing basic block for the instruction for every structured control-flow construct. However, when the control-flow constructs are the last instructions in their enclosing expression, the landing basic blocks will only contain a single branching instruction. Figure~\ref{fig:simplify-example} demonstrates an unoptimized example. On the right-hand side, the WebAssembly function is a simple function that returns 1 when the operand is an even number and 0 otherwise. On the left-hand side is its corresponding SableWasm MIR before simplification. Clearly, \texttt{\%BB:0} and \texttt{\%BB:1} are redundant. The redundant branch elimination pattern looks for basic blocks with a single inward flow and attempts to merge them with their predecessors. In the example, the optimizer will try to merge \texttt{\%BB:1} and \texttt{\%BB:4} by moving the \texttt{Constant} instruction into \texttt{\%BB:1}, and redirecting the branching in \texttt{\%BB:1} from \texttt{\%BB:4} to \texttt{\%exit}.

\paragraph{Dead basic block}
The third pattern we have in SableWasm simplify control-flow graph pass is dead basic block elimination. In figure~\ref{fig:simplify-example} , we have a dead basic block, namely \texttt{\%BB:2}. These dead basic blocks again come from   SableWasm's translation patterns. When we are translating the control flow constructs, we always prepare the landing basic block. However, in many cases, the control flow may not reach the landing basic block. In the example above, we have a WebAssembly \texttt{return} instruction appear in the \texttt{block}'s nested expression. The translation patterns for \texttt{return} instruction is naive, which creates a branch to the exiting block and configure the Phi nodes accordingly. Hence, in this case, the landing basic block will never have an inward flow. In SableWasm MIR, we do not consider these unreachable basic blocks invalid. However, in many backends, these are considered as bad behaviours. In addition, these basic blocks also interfere with other optimizations. In the example in figure~\ref{fig:simplify-example}, \texttt{\%BB:3} does not satisfy the redundant branching elimination pattern because it does not have a unique inward flow. However, one of them, \texttt{\%BB:3}, is a dead block. Thus, by removing dead basic blocks from the control-flow graph, we may find more optimization opportunities. In SableWasm, we identify the dead basic block via a mark-and-sweep algorithm. Starting from the entry block, we mark all the basic blocks that are reachable. Then we iterate overall basic blocks, and if the basic block does not have the flag, we add them to the delete list. Finally, we remove all the basic blocks within the delete list from the control flow graph.

\paragraph{Dead value}
The last pattern we have in the control-flow graph simplification pass is dead value elimination. Dead value elimination is similar to the dead basic block elimination, except that it works with values instead of basic blocks. Unfortunately, the example in figure~\ref{fig:simplify-example} does not contain any dead values. However, the idea is quite simple to understand. In a non-SSA control-flow graph, one usually needs first to perform liveness analysis and reaching def analysis to determine if the value is dead. But in SSA, one can quickly recover use-def chain, and in SableWasm, the base class \texttt{ASTNode} automatically manages it. Thus, the optimizer will iterate over all values within the control flow graph and check if others refer to it. If not, it then verifies if the instruction is droppable. A droppable instruction is an instruction such that if we remove it from the control flow graphs, no observable effects should happen, similar to the concept of `pure' for functions. Finally, if instructions are both dead and droppable, the optimizer will remove them from the control-flow graph.

\begin{figure}
    \lstinputlisting[
        basicstyle=\linespread{1}\small\ttfamily,
        language=SableWasmMIR,numbers=left
    ]{Code/4.MIR/simplify-cfg-result.mir}
    \caption{Control-flow graph simplification result}
    \label{fig:simplify-result}
\end{figure}

In this section, we cover the control-flow graph simplification pass in SableWasm. The optimizer will iteratively run four patterns that we have discussed above until it reaches a fixed point. Finally, we will conclude this section we an example of the simplified control-flow graph, shown in figure~\ref{fig:simplify-result}. Compared to the original one in figure~\ref{fig:simplify-example}, the result control-flow graph is more readable. Moreover, by reducing the amount of basic block, we can improve other analyses in SableWasm, and alleviate the pressure when lowering SableWasm MIR into backends.
