\subsection{Instructions Reduction}

This section will cover the instructions reduction rules used when lowering WebAssembly bytecode to SableWasm MIR. In the background chapter, we mentioned that one of WebAssembly's design goals is to be as compact as possible. When the community design the WebAssembly instruction set, they fuse several typical instruction sequences into single instructions. For example, SIMD vector operation extension defines \texttt{v128.load8x8\_s} which first load 8 single-byte integers into a vector, and then sign-extended them into 16 bit integers. Another example will be \texttt{v128.load32\_lane} which loads a 32-bit value, either a 32-bit integer or a single-precision floating-point number into a given vector. Such design is understandable for WebAssembly as binary size do matter when shipping application over the internet. But, for SableWasm, a static compiler, we focus more on the size of the instruction set instead of the size of the intermediate representation. It is harder to write analysis for a bloated instruction set, as one needs to consider more instruction cases. Hence, when lowering WebAssembly bytecode to SableWasm MIR, we replace some WebAssembly instructions with a sequence of SableWasm MIR instructions.


\paragraph{Eqz} \quad
\begin{lstlisting}[basicstyle=\linespread{1}\small, language=LLVM]
[..., %n i32] i32.eqz => %t0 = i32.const 0; %t1 = int.eq %n %t0
[..., %n i64] i64.eqz => %t0 = i64.const 0; %t1 = int.eq %n %t0
\end{lstlisting}
WebAssembly defines unary \texttt{eqz} operations for all integer values. As the name suggests, \texttt{eqz} compares the operand value against zero and yields to one if true, zero otherwise. In SableWasm MIR, we group all comparison instructions into \texttt{Compare} class, and \texttt{eqz} does not fit into the class as it is not a binary operation. Hence we rewrite the \texttt{eqz} as \texttt{Compare} instruction with opcode as \texttt{Eq}.

\paragraph{Load} \quad
\begin{lstlisting}[basicstyle=\linespread{1}\small, language=LLVM]
[..., %base i32] i32.load offset=%offset align=%align =>
    %addr = int.add %base %offset;
    memory.guard %mem %addr 4;
    %t0 = load.32 i32 %mem %addr
[..., %base i32] i32.load16_u offset=%offset align=%align =>
    %addr = int.add %base %offset;
    memory.guard %mem %addr 2;
    %t0 = load.16 i32 %mem %addr
[..., %base i32] i32.load16_s offset=%offset align=%align =>
    %addr = int.add %base %offset;
    memory.guard %mem %addr 2;
    %t0 = load.16 i32 %mem %addr;
    %t1 = cast i32.extend.16.s %t0
\end{lstlisting}

